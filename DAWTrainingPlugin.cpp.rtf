{\rtf1\ansi\ansicpg1252\cocoartf2865
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww28780\viewh17520\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 #include "DAWTrainingPlugin.h"\
\
//==============================================================================\
DAWTrainingProcessor::DAWTrainingProcessor()\
     : AudioProcessor (BusesProperties()\
                       // Main input/output\
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)\
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)\
                       // Sidechain support for Logic Pro\
                       .withInput  ("Sidechain", juce::AudioChannelSet::stereo(), false)),\
       parameters(*this, nullptr, "Parameters", createParameterLayout())\
\{\
    formatManager.registerBasicFormats();\
    \
    for (auto i = 0; i < 8; ++i)\
        synth.addVoice(new SynthVoice());\
    \
    synth.addSound(new SynthSound());\
    \
    compressor.setThreshold(-20.0f);\
    compressor.setRatio(4.0f);\
    compressor.setAttack(5.0f);\
    compressor.setRelease(100.0f);\
    \
    reverb.setParameters(\{0.5f, 0.5f, 0.33f, 0.67f, 1.0f, 0.0f\});\
    \
    fileReadThread.startThread(3);\
\}\
\
DAWTrainingProcessor::~DAWTrainingProcessor()\
\{\
    // Logic Pro fix: Proper cleanup sequence\
    stopPlayback();\
    fileReadThread.stopThread(2000);\
    transportSource.setSource(nullptr);\
    readerSource.reset();\
    \
    // Clear synth properly\
    synth.clearVoices();\
    synth.clearSounds();\
\}\
\
//==============================================================================\
juce::AudioProcessorValueTreeState::ParameterLayout DAWTrainingProcessor::createParameterLayout()\
\{\
    juce::AudioProcessorValueTreeState::ParameterLayout layout;\
    \
    // Logic Pro fix: Add string converters and proper ranges\
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "gain", "Gain", \
        juce::NormalisableRange<float>(0.0f, 2.0f, 0.01f), \
        1.0f,\
        juce::String(),\
        juce::AudioProcessorParameter::genericParameter,\
        [](float v, int) \{ return juce::String(v, 2); \},\
        [](const juce::String& s) \{ return s.getFloatValue(); \}));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "compThreshold", "Compressor Threshold", \
        juce::NormalisableRange<float>(-60.0f, 0.0f, 0.1f), \
        -20.0f,\
        "dB"));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "compRatio", "Compressor Ratio", \
        juce::NormalisableRange<float>(1.0f, 20.0f, 0.1f), \
        4.0f,\
        ":1"));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "reverbRoomSize", "Reverb Room Size", \
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f), \
        0.5f));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "reverbDamping", "Reverb Damping", \
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f), \
        0.5f));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "reverbWetLevel", "Reverb Wet Level", \
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f), \
        0.33f,\
        "%",\
        juce::AudioProcessorParameter::genericParameter,\
        [](float v, int) \{ return juce::String(int(v * 100)) + "%"; \},\
        [](const juce::String& s) \{ return s.getFloatValue() / 100.0f; \}));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "highPassFreq", "High Pass Frequency", \
        juce::NormalisableRange<float>(20.0f, 2000.0f, 1.0f, 0.25f), // Skew factor added\
        20.0f,\
        "Hz",\
        juce::AudioProcessorParameter::genericParameter,\
        [](float v, int) \{ return juce::String(v, 0) + " Hz"; \},\
        [](const juce::String& s) \{ return s.getFloatValue(); \}));\
    \
    layout.add(std::make_unique<juce::AudioParameterFloat>(\
        "lowPassFreq", "Low Pass Frequency", \
        juce::NormalisableRange<float>(1000.0f, 20000.0f, 1.0f, 0.5f), // Skew factor added\
        20000.0f,\
        "Hz",\
        juce::AudioProcessorParameter::genericParameter,\
        [](float v, int) \{ return juce::String(v, 0) + " Hz"; \},\
        [](const juce::String& s) \{ return s.getFloatValue(); \}));\
    \
    return layout;\
\}\
\
//==============================================================================\
void DAWTrainingProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\
\{\
    // Logic Pro fix: Handle invalid sample rates\
    if (sampleRate <= 0.0 || samplesPerBlock <= 0)\
    \{\
        DBG("Invalid prepareToPlay parameters - sampleRate: " << sampleRate \
            << ", samplesPerBlock: " << samplesPerBlock);\
        return;\
    \}\
    \
    // Logic Pro fix: Detect sample rate changes\
    bool sampleRateChanged = std::abs(currentSampleRate.load() - sampleRate) > 0.01;\
    \
    if (sampleRateChanged && isPreparationComplete.load())\
    \{\
        DBG("Sample rate change detected: " << currentSampleRate.load() << " -> " << sampleRate);\
        handleSampleRateChange(sampleRate, samplesPerBlock);\
    \}\
    else\
    \{\
        handleSampleRateChange(sampleRate, samplesPerBlock);\
        isPreparationComplete.store(true);\
    \}\
    \
    currentSampleRate.store(sampleRate);\
\}\
\
void DAWTrainingProcessor::handleSampleRateChange(double sampleRate, int samplesPerBlock)\
\{\
    // Store current parameter values\
    auto currentGain = parameters.getRawParameterValue("gain")->load();\
    auto currentThreshold = parameters.getRawParameterValue("compThreshold")->load();\
    auto currentRatio = parameters.getRawParameterValue("compRatio")->load();\
    \
    // Stop any playback during reconfiguration\
    if (transportSource.isPlaying())\
    \{\
        transportSource.stop();\
    \}\
    \
    // Create DSP spec\
    juce::dsp::ProcessSpec spec;\
    spec.sampleRate = sampleRate;\
    spec.maximumBlockSize = static_cast<juce::uint32>(samplesPerBlock);\
    spec.numChannels = 2; // Force stereo for Logic compatibility\
    \
    // Reset all DSP components\
    compressor.reset();\
    reverb.reset();\
    highPassFilter.reset();\
    lowPassFilter.reset();\
    \
    // Prepare DSP components\
    compressor.prepare(spec);\
    reverb.prepare(spec);\
    \
    // Restore compressor settings\
    compressor.setThreshold(currentThreshold);\
    compressor.setRatio(currentRatio);\
    \
    // Update filter coefficients\
    auto hpFreq = parameters.getRawParameterValue("highPassFreq")->load();\
    auto lpFreq = parameters.getRawParameterValue("lowPassFreq")->load();\
    \
    highPassFilter.state = juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, hpFreq);\
    lowPassFilter.state = juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, lpFreq);\
    \
    highPassFilter.prepare(spec);\
    lowPassFilter.prepare(spec);\
    \
    lastHighPassFreq.store(hpFreq);\
    lastLowPassFreq.store(lpFreq);\
    \
    // Reset gain smoothing\
    gainSmoothed.reset(sampleRate, 0.01);\
    gainSmoothed.setCurrentAndTargetValue(currentGain);\
    \
    // Update synthesizer\
    synth.setCurrentPlaybackSampleRate(sampleRate);\
    \
    // Prepare transport last\
    bufferingSource.prepareToPlay(samplesPerBlock, sampleRate);\
\}\
\
void DAWTrainingProcessor::releaseResources()\
\{\
    bufferingSource.releaseResources();\
    highPassFilter.reset();\
    lowPassFilter.reset();\
    compressor.reset();\
    reverb.reset();\
\}\
\
bool DAWTrainingProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\
\{\
    // Logic Pro fix: Handle various configurations including dual mono\
    auto mainInput = layouts.getMainInputChannelSet();\
    auto mainOutput = layouts.getMainOutputChannelSet();\
    \
    // Support mono->mono (for Logic's dual mono mode)\
    if (mainInput == juce::AudioChannelSet::mono())\
    \{\
        return mainOutput == juce::AudioChannelSet::mono() \
            || mainOutput == juce::AudioChannelSet::stereo();\
    \}\
    \
    // Support stereo->stereo (standard mode)\
    if (mainInput == juce::AudioChannelSet::stereo())\
    \{\
        return mainOutput == juce::AudioChannelSet::stereo();\
    \}\
    \
    // Logic Pro 10.5+ surround support\
    if (mainOutput == juce::AudioChannelSet::create7point1point4())\
        return layouts.getMainInputChannelSet() == mainOutput;\
    \
    // Support sidechain input\
    if (layouts.getInputBuses().size() > 1)\
    \{\
        auto sidechain = layouts.getChannelSet(true, 1);\
        if (!sidechain.isDisabled() && sidechain != juce::AudioChannelSet::stereo())\
            return false;\
    \}\
    \
    return false;\
\}\
\
void DAWTrainingProcessor::processBlock (juce::AudioBuffer<float>& buffer,\
                                         juce::MidiBuffer& midiMessages)\
\{\
    // Logic Pro fix: Handle zero-sample buffers\
    if (buffer.getNumSamples() <= 0)\
        return;\
    \
    // Logic Pro fix: Handle very large buffers\
    if (buffer.getNumSamples() > 8192)\
    \{\
        DBG("Warning: Unusually large buffer size: " << buffer.getNumSamples());\
    \}\
    \
    juce::ScopedNoDenormals noDenormals;\
    \
    // Clear unused channels\
    for (auto i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i)\
        buffer.clear(i, 0, buffer.getNumSamples());\
    \
    // Input metering\
    float maxInput = 0.0f;\
    for (int channel = 0; channel < getTotalNumInputChannels(); ++channel)\
        maxInput = std::max(maxInput, buffer.getMagnitude(channel, 0, buffer.getNumSamples()));\
    inputLevel.setTargetValue(maxInput);\
    inputLevel.tick();\
    \
    // Get transport state from host (Logic Pro)\
    if (auto* playHead = getPlayHead())\
    \{\
        juce::AudioPlayHead::CurrentPositionInfo pos;\
        if (playHead->getCurrentPosition(pos))\
        \{\
            // Sync with Logic's transport\
            if (audioFileLoaded.load())\
            \{\
                if (pos.isPlaying && !transportSource.isPlaying())\
                    transportSource.start();\
                else if (!pos.isPlaying && transportSource.isPlaying())\
                    transportSource.stop();\
            \}\
        \}\
    \}\
    \
    // MIDI processing\
    synth.renderNextBlock(buffer, midiMessages, 0, buffer.getNumSamples());\
    \
    // Audio file playback\
    if (audioFileLoaded.load() && transportSource.isPlaying())\
    \{\
        juce::AudioBuffer<float> fileBuffer(buffer.getNumChannels(), buffer.getNumSamples());\
        juce::AudioSourceChannelInfo info(&fileBuffer, 0, buffer.getNumSamples());\
        \
        // Use try-catch for safety\
        try \{\
            bufferingSource.getNextAudioBlock(info);\
            \
            for (int channel = 0; channel < buffer.getNumChannels(); ++channel)\
                buffer.addFrom(channel, 0, fileBuffer, channel, 0, buffer.getNumSamples());\
        \}\
        catch (...) \{\
            DBG("Error reading audio file");\
        \}\
    \}\
    \
    juce::dsp::AudioBlock<float> block(buffer);\
    juce::dsp::ProcessContextReplacing<float> context(block);\
    \
    // Update filters only if changed\
    float currentHighPass = parameters.getRawParameterValue("highPassFreq")->load();\
    float currentLowPass = parameters.getRawParameterValue("lowPassFreq")->load();\
    \
    if (std::abs(currentHighPass - lastHighPassFreq.load()) > 0.01f)\
    \{\
        highPassFilter.state = juce::dsp::IIR::Coefficients<float>::makeHighPass(\
            currentSampleRate.load(), currentHighPass);\
        lastHighPassFreq.store(currentHighPass);\
    \}\
    \
    if (std::abs(currentLowPass - lastLowPassFreq.load()) > 0.01f)\
    \{\
        lowPassFilter.state = juce::dsp::IIR::Coefficients<float>::makeLowPass(\
            currentSampleRate.load(), currentLowPass);\
        lastLowPassFreq.store(currentLowPass);\
    \}\
    \
    highPassFilter.process(context);\
    lowPassFilter.process(context);\
    \
    // Compressor\
    compressor.setThreshold(parameters.getRawParameterValue("compThreshold")->load());\
    compressor.setRatio(parameters.getRawParameterValue("compRatio")->load());\
    compressor.process(context);\
    \
    // Reverb\
    juce::dsp::Reverb::Parameters reverbParams;\
    reverbParams.roomSize = parameters.getRawParameterValue("reverbRoomSize")->load();\
    reverbParams.damping = parameters.getRawParameterValue("reverbDamping")->load();\
    reverbParams.wetLevel = parameters.getRawParameterValue("reverbWetLevel")->load();\
    reverbParams.dryLevel = 1.0f - reverbParams.wetLevel;\
    reverbParams.width = 1.0f;\
    reverbParams.freezeMode = 0.0f;\
    reverb.setParameters(reverbParams);\
    reverb.process(context);\
    \
    // Apply smoothed gain\
    gainSmoothed.setTargetValue(parameters.getRawParameterValue("gain")->load());\
    \
    for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\
    \{\
        auto gain = gainSmoothed.getNextValue();\
        for (int channel = 0; channel < buffer.getNumChannels(); ++channel)\
            buffer.setSample(channel, sample, buffer.getSample(channel, sample) * gain);\
    \}\
    \
    // Output metering\
    float maxOutput = 0.0f;\
    for (int channel = 0; channel < getTotalNumOutputChannels(); ++channel)\
        maxOutput = std::max(maxOutput, buffer.getMagnitude(channel, 0, buffer.getNumSamples()));\
    outputLevel.setTargetValue(maxOutput);\
    outputLevel.tick();\
\}\
\
void DAWTrainingProcessor::loadAudioFile(const juce::File& file)\
\{\
    // Thread safety check\
    if (!file.existsAsFile()) \
    \{\
        juce::MessageManager::callAsync([file] \{\
            juce::AlertWindow::showMessageBoxAsync(\
                juce::AlertWindow::WarningIcon,\
                "File Error",\
                "File does not exist: " + file.getFullPathName());\
        \});\
        return;\
    \}\
    \
    // Stop transport before changing source\
    stopPlayback();\
    \
    auto* reader = formatManager.createReaderFor(file);\
    \
    if (reader != nullptr)\
    \{\
        transportSource.setSource(nullptr);\
        \
        auto newSource = std::make_unique<juce::AudioFormatReaderSource>(reader, true);\
        transportSource.setSource(newSource.get(), 0, nullptr, reader->sampleRate);\
        readerSource = std::move(newSource);\
        audioFileLoaded.store(true);\
        \
        // Logic Pro fix: Use async callback for UI updates\
        juce::MessageManager::callAsync([this] \{\
            sendChangeMessage();\
        \});\
    \}\
    else\
    \{\
        juce::MessageManager::callAsync([file] \{\
            juce::AlertWindow::showMessageBoxAsync(\
                juce::AlertWindow::WarningIcon,\
                "File Error",\
                "Unable to read audio file: " + file.getFileName());\
        \});\
    \}\
\}\
\
void DAWTrainingProcessor::startPlayback()\
\{\
    if (audioFileLoaded.load())\
        transportSource.start();\
\}\
\
void DAWTrainingProcessor::stopPlayback()\
\{\
    transportSource.stop();\
\}\
\
//==============================================================================\
juce::AudioProcessorEditor* DAWTrainingProcessor::createEditor()\
\{\
    return new DAWTrainingEditor (*this);\
\}\
\
//==============================================================================\
void DAWTrainingProcessor::getStateInformation (juce::MemoryBlock& destData)\
\{\
    auto state = parameters.copyState();\
    std::unique_ptr<juce::XmlElement> xml(state.createXml());\
    copyXmlToBinary(*xml, destData);\
\}\
\
void DAWTrainingProcessor::setStateInformation (const void* data, int sizeInBytes)\
\{\
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));\
    \
    if (xmlState != nullptr && xmlState->hasTagName(parameters.state.getType()))\
        parameters.replaceState(juce::ValueTree::fromXml(*xmlState));\
\}\
\
//==============================================================================\
// SynthVoice Implementation\
bool SynthVoice::canPlaySound (juce::SynthesiserSound* sound)\
\{\
    return dynamic_cast<SynthSound*>(sound) != nullptr;\
\}\
\
void SynthVoice::startNote (int midiNoteNumber, float velocity,\
                juce::SynthesiserSound*, int)\
\{\
    currentAngle = 0.0;\
    level = velocity * 0.15;\
    tailOff = 0.0;\
    \
    auto cyclesPerSecond = juce::MidiMessage::getMidiNoteInHertz (midiNoteNumber);\
    auto cyclesPerSample = cyclesPerSecond / getSampleRate();\
    \
    angleDelta = cyclesPerSample * juce::MathConstants<double>::twoPi;\
\}\
\
void SynthVoice::stopNote (float, bool allowTailOff)\
\{\
    if (allowTailOff)\
    \{\
        if (tailOff == 0.0)\
            tailOff = 1.0;\
    \}\
    else\
    \{\
        clearCurrentNote();\
        angleDelta = 0.0;\
    \}\
\}\
\
void SynthVoice::renderNextBlock (juce::AudioBuffer<float>& outputBuffer, \
                                  int startSample, int numSamples)\
\{\
    if (angleDelta == 0.0) return;\
    \
    if (tailOff > 0.0)\
    \{\
        while (--numSamples >= 0)\
        \{\
            auto currentSample = static_cast<float>(std::sin(currentAngle) * level * tailOff);\
            \
            for (auto i = outputBuffer.getNumChannels(); --i >= 0;)\
                outputBuffer.addSample(i, startSample, currentSample);\
            \
            currentAngle += angleDelta;\
            ++startSample;\
            \
            tailOff *= 0.99;\
            \
            if (tailOff <= 0.005)\
            \{\
                clearCurrentNote();\
                angleDelta = 0.0;\
                break;\
            \}\
        \}\
    \}\
    else\
    \{\
        while (--numSamples >= 0)\
        \{\
            auto currentSample = static_cast<float>(std::sin(currentAngle) * level);\
            \
            for (auto i = outputBuffer.getNumChannels(); --i >= 0;)\
                outputBuffer.addSample(i, startSample, currentSample);\
            \
            currentAngle += angleDelta;\
            ++startSample;\
        \}\
    \}\
\}\
\
//==============================================================================\
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\
\{\
    return new DAWTrainingProcessor();\
\}}