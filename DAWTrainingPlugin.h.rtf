{\rtf1\ansi\ansicpg1252\cocoartf2865
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 #pragma once\
\
#include <JuceHeader.h>\
#include <memory>\
#include <atomic>\
\
//==============================================================================\
class DAWTrainingProcessor : public juce::AudioProcessor,\
                             public juce::ChangeBroadcaster\
\{\
public:\
    DAWTrainingProcessor();\
    ~DAWTrainingProcessor() override;\
\
    //==============================================================================\
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;\
    void releaseResources() override;\
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;\
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;\
    using AudioProcessor::processBlock;\
\
    //==============================================================================\
    juce::AudioProcessorEditor* createEditor() override;\
    bool hasEditor() const override \{ return true; \}\
\
    //==============================================================================\
    const juce::String getName() const override \{ return "DAW Training Plugin"; \}\
    \
    // Version info for Logic Pro AU validation\
    const juce::String getVersion() const \{ return "1.0.1"; \}\
    \
    bool acceptsMidi() const override \{ return true; \}\
    bool producesMidi() const override \{ return false; \}\
    bool isMidiEffect() const override \{ return false; \}\
    double getTailLengthSeconds() const override \{ return reverb.getParameters().roomSize * 2.0; \}\
\
    //==============================================================================\
    int getNumPrograms() override \{ return 1; \}\
    int getCurrentProgram() override \{ return 0; \}\
    void setCurrentProgram (int) override \{\}\
    const juce::String getProgramName (int) override \{ return \{\}; \}\
    void changeProgramName (int, const juce::String&) override \{\}\
\
    //==============================================================================\
    void getStateInformation (juce::MemoryBlock& destData) override;\
    void setStateInformation (const void* data, int sizeInBytes) override;\
\
    //==============================================================================\
    juce::AudioProcessorValueTreeState parameters;\
    \
    void loadAudioFile(const juce::File& file);\
    bool isAudioFileLoaded() const \{ return audioFileLoaded.load(); \}\
    void startPlayback();\
    void stopPlayback();\
    bool isPlaying() const \{ return transportSource.isPlaying(); \}\
    \
    float getCurrentInputLevel() const \{ return inputLevel.getCurrentValue(); \}\
    float getCurrentOutputLevel() const \{ return outputLevel.getCurrentValue(); \}\
\
private:\
    //==============================================================================\
    // Audio Format and Threading\
    juce::AudioFormatManager formatManager;\
    std::unique_ptr<juce::AudioFormatReaderSource> readerSource;\
    juce::TimeSliceThread fileReadThread\{"File Reader Thread"\};\
    juce::AudioTransportSource transportSource;\
    juce::BufferingAudioSource bufferingSource\{&transportSource, fileReadThread, \
                                                false, 32768, 2\};\
    std::atomic<bool> audioFileLoaded\{false\};\
    \
    // DSP Components\
    juce::dsp::Compressor<float> compressor;\
    juce::dsp::Reverb reverb;\
    \
    using Filter = juce::dsp::IIR::Filter<float>;\
    using FilterCoefs = juce::dsp::IIR::Coefficients<float>;\
    using Duplicator = juce::dsp::ProcessorDuplicator<Filter, FilterCoefs>;\
    Duplicator highPassFilter, lowPassFilter;\
    \
    // Synthesizer\
    juce::Synthesiser synth;\
    \
    // Smoothed Parameters\
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> gainSmoothed;\
    \
    // Metering with decay\
    class DecayingValue\
    \{\
    public:\
        void setTargetValue(float newValue) \
        \{ \
            auto currentVal = current.load();\
            target.store(newValue > currentVal ? newValue : target.load());\
        \}\
        \
        void tick() \
        \{ \
            auto targetVal = target.load();\
            current.store(targetVal);\
            target.store(targetVal * 0.95f);\
            if (targetVal < 0.001f) target.store(0.0f);\
        \}\
        \
        float getCurrentValue() const \{ return current.load(); \}\
        \
    private:\
        std::atomic<float> current\{0.0f\}, target\{0.0f\};\
    \};\
    \
    DecayingValue inputLevel, outputLevel;\
    \
    // Parameter tracking for efficient filter updates\
    std::atomic<float> lastHighPassFreq\{-1.0f\};\
    std::atomic<float> lastLowPassFreq\{-1.0f\};\
    \
    // Logic Pro specific state tracking\
    std::atomic<double> currentSampleRate\{44100.0\};\
    std::atomic<bool> isPreparationComplete\{false\};\
    \
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();\
    void handleSampleRateChange(double newSampleRate, int samplesPerBlock);\
    \
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DAWTrainingProcessor)\
\};\
\
//==============================================================================\
class DAWTrainingEditor : public juce::AudioProcessorEditor,\
                          public juce::Timer,\
                          public juce::ChangeListener,\
                          public juce::FileDragAndDropTarget\
\{\
public:\
    DAWTrainingEditor (DAWTrainingProcessor&);\
    ~DAWTrainingEditor() override;\
\
    void paint (juce::Graphics&) override;\
    void resized() override;\
    void timerCallback() override;\
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;\
    \
    bool isInterestedInFileDrag (const juce::StringArray& files) override;\
    void filesDropped (const juce::StringArray& files, int x, int y) override;\
\
private:\
    DAWTrainingProcessor& processor;\
    \
    // GUI Components\
    juce::Slider gainSlider;\
    juce::Slider compressorThresholdSlider;\
    juce::Slider compressorRatioSlider;\
    juce::Slider reverbRoomSizeSlider;\
    juce::Slider reverbDampingSlider;\
    juce::Slider reverbWetLevelSlider;\
    juce::Slider highPassFreqSlider;\
    juce::Slider lowPassFreqSlider;\
    \
    juce::TextButton loadFileButton;\
    juce::TextButton playButton;\
    juce::TextButton stopButton;\
    \
    juce::Label statusLabel;\
    juce::Label inputMeterLabel;\
    juce::Label outputMeterLabel;\
    \
    // Meter Component\
    class SimpleLevelMeter : public juce::Component\
    \{\
    public:\
        void setLevel(float newLevel) \
        \{ \
            level = juce::jlimit(0.0f, 1.0f, newLevel); \
            repaint(); \
        \}\
        void paint(juce::Graphics& g) override;\
        \
    private:\
        float level = 0.0f;\
    \};\
    \
    SimpleLevelMeter inputMeter;\
    SimpleLevelMeter outputMeter;\
    \
    // Parameter attachments\
    using SliderAttachment = juce::AudioProcessorValueTreeState::SliderAttachment;\
    std::unique_ptr<SliderAttachment> gainAttachment;\
    std::unique_ptr<SliderAttachment> compressorThresholdAttachment;\
    std::unique_ptr<SliderAttachment> compressorRatioAttachment;\
    std::unique_ptr<SliderAttachment> reverbRoomSizeAttachment;\
    std::unique_ptr<SliderAttachment> reverbDampingAttachment;\
    std::unique_ptr<SliderAttachment> reverbWetLevelAttachment;\
    std::unique_ptr<SliderAttachment> highPassFreqAttachment;\
    std::unique_ptr<SliderAttachment> lowPassFreqAttachment;\
\
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DAWTrainingEditor)\
\};\
\
//==============================================================================\
class SynthVoice : public juce::SynthesiserVoice\
\{\
public:\
    bool canPlaySound (juce::SynthesiserSound* sound) override;\
    void startNote (int midiNoteNumber, float velocity,\
                    juce::SynthesiserSound*, int) override;\
    void stopNote (float, bool allowTailOff) override;\
    void pitchWheelMoved (int) override \{\}\
    void controllerMoved (int, int) override \{\}\
    void renderNextBlock (juce::AudioBuffer<float>& outputBuffer, \
                         int startSample, int numSamples) override;\
    using SynthesiserVoice::renderNextBlock;\
    \
private:\
    double currentAngle = 0.0, angleDelta = 0.0, level = 0.0, tailOff = 0.0;\
\};\
\
//==============================================================================\
struct SynthSound : public juce::SynthesiserSound\
\{\
    SynthSound() \{\}\
    bool appliesToNote (int) override \{ return true; \}\
    bool appliesToChannel (int) override \{ return true; \}\
\};}